This section is about automated testing.


-----------------What is testing?
Till this stage we have done manual testing. Like debugging our code manually and previewing our application in browser and again test there manually.

But in case of automated testing all the code will be tested automatically no matters where you make changes in the code.

------------Different types of tests
Unite Tests (Testing the individual building blocks such as functions, code blocks or components)
Integration Tests (Here we test the combination of multiple building blocks. Like one component is dependent on other component. Its not very common test. )
End-to-End (e2e) Tests (This is the testing of entire scenario like the complete authentication system)


----------------Tool
for runnig the test we use JEST  (JEST is not specific to react it is a general JS library)
for rending our react app we use React Testing Library.
there is anotoher library called React-hook testing library you can use them too.

Luckily both tools are already set up and when you install react app. There is no need to externally install them.

---------------------JEST
To use testing we use: 
import '@testing-library/jest-dom';

The convention is that you must have to name you test file as you component file just add test name at the end.

----------------Pre-reqs

First create a test setup file namely setupTest.js in the src folder
//In setupTest.js
import '@testing-library/jest-dom';


Now create another file The convention is that you must have to name you test file as you component file just add test name at the end.
for example for testing App.js you have to create App.test.js
//now in App.test.js

import '@testing-library/jest-dom'
import { render, screen } from "@testing-library/react";
import App from "./App";

test("renders learn react link", () => {
  render(<App />);
  const linkElement = screen.getByText(/Learn React/i);
  expect(linkElement).toBeInTheDocument();
});

// and here if there is a component "Learn React" 
The test will run the component. Luckily its not case sensitive.

IMPORTANT: for the safe side you can install "npm i @testing-library/jest-dom"


Now to run test simple type:

> npm test
-------------------------Writing Custom test
To Wirte a custom test you have to follow some rules like 3 A's rule

1. Arrange (Setting test data, conditions and environment)
2. Act (Run logic that should be tested e.g. execute function)
3. Assert (Compare execution results with expected results)

//In Greeting.js file

import React from "react";

export default function Greeting() {
  return (
    <div>
      <h2>Hello World</h2>
      <p>
        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Adipisci porro
        illum, est ut quam possimus iure iusto corrupti praesentium minima sit
        suscipit, aliquid vel. Animi minima error distinctio amet labore.
      </p>
    </div>
  );
}



// In Greeting.Test.js file


import Greeting from "./Greeting";
import { render, screen } from "@testing-library/react";

test('Render Hellos world as text', ()=>{
    // Arrange
    render(<Greeting/>);

    //Act 
    // (But here act is nothing)

    //Assert
    const helloWorldElement = screen.getByText('Hello World', {exact: false});
    expect(helloWorldElement).toBeInTheDocument();
}); 

// here test is the built in function which will be run on running the test. It takes two argument one is the name or sentence about test and a callback function.
//here screen is like virtual DOM 
//here exact: false will give us leniency in matching the text.
//where as if exact: true will match exactly event the full stop :)
--------------Wiritng test for greeting file

--Extra info

here .get() method shows error on finding the value
.query() this do not throw any errors
.find() this method returns a promise.


---------------how to group mulitple test
for grouping test you have to make suits using describe function

import Greeting from "./Greeting";
import { render, screen } from "@testing-library/react";

describe("Greeitng component", () => {
  test("Render Hellos world as text", () => {
    // Arrange
    render(<Greeting />);

    //Act
    // (But here act is nothing)

    //Assert
    const helloWorldElement = screen.getByText("Hello World", { exact: false });
    expect(helloWorldElement).toBeInTheDocument();
  });
test('your logic');
test('your logic');
test('your logic');
});


here you can run multiple tests inside describe function.



--------------------------Test for states
//In Greeting.js Component

import React from "react";
import { useState } from "react";
export default function Greeting() {
  const [changeText, setChangeText] = useState(false);
  const changeTextHandler = () => {
    setChangeText(true);
  };
  return (
    <div>
      <h2>Hello World</h2>
      {!changeText && <p>Its good to see you.</p>}
      {changeText && <p>Changed!</p>}
      <button onClick={changeTextHandler}>Change</button>
    </div>
  );
}

// In Greeting.test.js

import Greeting from "./Greeting";
import userEvent from "@testing-library/user-event";
import { render, screen } from "@testing-library/react";

describe("Greeitng component", () => {
  test("Render Hellos world as text", () => {
    // Arrange
    render(<Greeting />);

    //Act
    // (But here act is nothing)

    //Assert
    const helloWorldElement = screen.getByText("Hello World", { exact: false });
    expect(helloWorldElement).toBeInTheDocument();
});
test('Renders good to see you if the button was NOT clicked', ()=> {
    //Arrange
    render(<Greeting/>);
    //Act
    // (But here act is nothing)
    
    //Assert
    const outputElement = screen.getByText("Its good to see you", { exact: false });
    expect(outputElement).toBeInTheDocument();

  });
test('Renders Changed! if the button was click', ()=> {
    //Arrange
    render(<Greeting/>);
    //Act
    const buttonElement = screen.getByRole('button');
    userEvent.click(buttonElement)  
    
    //Assert
    const outputElement = screen.getByText("Changed!", { exact: false });
    expect(outputElement).toBeInTheDocument() ;

  });
});





//here screen is like virtual DOM
//here exact: false will give us leniency in matching the text.
//where as if exact: true will match exactly event the full stop :)


//Here screen is DOM and here its not an HTML or windows DOM its a DOM of React component on which are running our test. This is like so that we can access our React component element and write rest for them



---------------Precautions
while working test with async code in which we are sending request to the servers to fetch the data. Its not be done. Like while testing we should NOT send request to server. Or we should send request to a fake test server.
Always remember. You have to run test on functions which are written by you. Like you dont have to run tests for built in functions like fetch() cause we trust the react developer and testing a function simply means whether it is working as expected or not. SO for built in functions we believe that they are already tested from the React Developers and there is no need to test them. We are only responsible for the functions which we have written by ourselves

But how can we replace fetch with a dummy function?

fetch('url').then(response => response.json()).then(data => console.log(data));
//simply to make the above function a mock or dummy function replace it by below:

window.fetch = jest.fn();
window.fetch.MockResolvedValueOnce({json: async()=> [{id: 'p1', title:'First post'}]})


in this way we are not sending any request to the real server instead we are using our mock function and its behaviour is controlled. 
By mocking the fetch function, you can control its behavior and simulate responses without actually making network requests. This is particularly useful during testing, as it allows you to isolate and test specific parts of your code without relying on external APIs or making actual network calls.