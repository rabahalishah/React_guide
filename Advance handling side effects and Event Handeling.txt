All the below hooks are used for dealing with the complex states.
 
-----------useEffect()


useEffect is a React Hook that lets you synchronize a component with an external system.
The main job of this hook is to handle the side effects. so for that you have underdstand what are side effects. Side effects are the action which are perform in the action of some entered data. For example form validation, http requests etc.
Its another hook use to manage side effects. it take two arguments one is callback function which  must be executed after every component evaluation if the specified dependencies are changed. These dependencies (full of arrays) are the second argument that we take.

useEffect = (()=>{}, [dependencies]);

Application Example: Once you created your app having login page once the user has entered all his detailed and once his profile has authenticated then if he reloads his page then the page should NOT ask him again to enter the credentials. So this means that we have somewhere persist this information so on reloading or coming back to the login page the user should not have any need to again enter his details.

UseEffect function runs once after all the components has ran.

-------------What to add what to NOT in dependencies


You learned, that you should add "everything" you use in the effect function as a dependency - i.e. all state variables and functions you used in there.

That is correct, but there are a few exceptions you should be aware:
Note we always select and add those thing in dependencies which may change in future. But those thing about which we are 100% sure that thing is not gonna change you dont need to enter that thing.
such as set state function which we get as a return from useState hook.

Also NO need to add built-in functions such as fetch(), localStorage etc. 
Also NO need to add variables or functions which you may have defined outside of you component

So long story short: You must add all "things" you use in your effect function if those "things" could change because your component (or some parent component) re-rendered. That's why variables or state defined in component functions, props or functions defined in component functions have to be added as dependencies!

Here's a made-up dummy example to further clarify the above-mentioned scenarios:

import { useEffect, useState } from 'react';
 
let myTimer;
 
const MyComponent = (props) => {
  const [timerIsActive, setTimerIsActive] = useState(false);
 
  const { timerDuration } = props; // using destructuring to pull out specific props values
 
  useEffect(() => {
    if (!timerIsActive) {
      setTimerIsActive(true);
      myTimer = setTimeout(() => {
        setTimerIsActive(false);
      }, timerDuration);
    }
  }, [timerIsActive, timerDuration]);
};

---------------Passing objects to dependencies

const { someProperty } = someObject; // destructuring
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);
This is a very common pattern and approach.

----------------------------------------useReducer()
Sometimes it becomes harder and error prone using useState due to the complexity of the state. In such scenarios this hook can be used as the replacement for useState().

function reducer(state, action) {
}
const [state, dispatch] = useReducer(reducer, initialArg, init?)

here init? is optional
here the state is same as useState that is you can say initial state. The second dispatch function is state updating function but will work differently from useState.
here initialArg will be in the form of object {key:value} instead of actual value as in the useState hook. Important point to note that the dipatch will call to reducer function for us.
here every time we call dispatch it will pass to action keyword in reducer function and action will be perform and an object
you can see state like this:

state = {key:value}

since dispatch is a setState function you can also specify its type and by using if else or switch case condition you can also merge other functionality into reducer function.
and this "type" keyword would be an array for action so we can see actions like that:
action: ['cool', 'hot']


------Example
Managing state with useState hook:

import React, { useState } from "react";

const App = () => {
  const [count, setCount] = useState(0);
  function increment() {
    setCount((prevCount) => prevCount + 1);
  }
  function decrement() {
    setCount((prevCount) => prevCount - 1);
  }
  return (
    <div>
      <button onClick={decrement}>-</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  );
};

export default App;


Converting State with useReducer:

import React, { useReducer } from "react";

const App = () => {
  const ACTIONS = {
    INCREMENT: 'increment',
    DECREMENT: 'decrement'
  }
  function reducer(state, action) {
    if (action.type === ACTIONS.INCREMENT) {
      return { count: state.count + 1 };
    } else if (action.type === ACTIONS.DECREMENT) {
      return { count: state.count - 1 };
    } else {
      return state;
    }
  }
  const [state, dispatch] = useReducer(reducer, { count: 0 });
  function increment() {
    dispatch({ type: ACTIONS.INCREMENT });
  }
  function decrement() {
    dispatch({ type: ACTIONS.DECREMENT });
  }

  return (
    <div>
      <button onClick={decrement}>-</button>
      <span style={{ color: "white" }}>{state.count}</span>
      <button onClick={increment}>+</button>
    </div>
  );
};

export default App;




NOTE that dispatch(action) dispatch function take action as arguments.
so we can see our actions as:
action= { type: ACTIONS.INCREMENT }
action= { type: ACTIONS.DECREMENT }

-------------------Optional Payload property

There is also a property other than "type" which we used to pass to reducer action for passing the information as we know info is not status which we send via type to reducer action.


-----------------------useState vs useReducer

useState() is your main state management tool

useReducer will be used when data is related to each other. This would be helpful for managing more complex state.

You can first go with useState and then make it to reducer hook

-------------------React Context
This hook allows us to pass and update data deeply in the tree (our app components tree).
This is very helpful like if you want to send some props to a component which is in another component then you dont need to go through complex way
**Method 1
You simply have to createContext() This function will contain you data in the form of object which you want to pass. Simply wrap the parent component with thir wrapper:

// Creating context in auth-context file

import { createContext, React } from 'react';

const AuthContext = React.createContext({
  isloggedIn: false
}) 


export default AuthContext;

// In app.js

return (
<AuthContext.provider value{{fruit: 'Apple' }}>
	....your HTML/JSX
</AuthContext.provider>
)

now all the content in this wrapper have access to  AuthContext function in auth-context.js file.
in value you can provide as many values you want even you can pass functions via values
now to consume it you have to go the file where you want to consume this data:

return (
<AuthContext.consumer>

{(ctx)=>{ return (
	....your HTML/JSX
	console.log(ctx.fruit)  //apple
)}}
	
</AuthContext.consumer>
)


//Here we have wrapped it and created a function having ctx parameter and returning our content. Here ctx parameter will have take take the object that we created in AuthContext function.


**Method 2 (recommended):

The second method is quite clean.

All steps are same as above. Except the place where you want to consume your context.
now to consume context you have to do:

import { useContext } from 'react';

function componentFunction() {
  const ctx = useContext(AuthContext);

//useContext return the object/content which is available in authContext function

you can use data from ctx as 

console.log(ctx.isLoggedIn )



//NOTE: You can also pass functions in value keyword in your context component
Use context hook when you have to perform a very specific value or action



-----------Limitations of React Context
It is not suitable for high optimized changes.
It should not be replace across all the components

--------------forwardRef()
const MyInput = forwardRef(function MyInput(props, ref) {
  return (
    <label>
      {props.label}
      <input ref={ref} />
    </label>
  );
});

forward ref is used to forward ref through multiple components.
and to work with imperativeHandle 

----------------useImperativeHandle Hooks

this Hook is use to make your ref work entirely different. OR you can say by this hook you can make your custom ref.
This Hook combined with forwardref will help you pass you ref value to multiple components to connect them by ref where connecting components by props doesnt make sense

useImperativeHandle(ref, callback, dependencies)
OR
useImperativeHandle(ref, () => {}, [])

To use ImperativeHandle hook you must have to create some refs in you parent and child components between which you wanna make some relation.

Ok so let say I want to pass my ref functions (we know ref could be an obj or function which will work customly due to useImperativeHandle) to parent component.
so first create your ref using useRef and pass its value to the element like input tag etc.

now use useImperativeHandle and in second argument create you ref function. Now you can use these functions outside your child component WOOWWWW...!
so now go to your parent component or where you want to use them.
create another ref using useRef in parent component. 
and then you the element where you want link this ref. Create a callback function there you can use it like this: 
() => myParentRef.current.childRefFunction()
//Here childRefFunction is a ref function created in child component inside the useImperative Hook.
// and myParentRef is name of useRef like:  const myParentRef = useRef();



-----------Example:

// Child Component
import {useImperativeHandle, useRef } from 'react';
function MyChild(ref) {
const closeRef = useRef();  
const confirmRef = useRef();  

useImperativeHandle(ref, () =>  {
return {
  focusCloseRef : () => closeRef.current.focus(),
  focusConfirmRef : () => confirmRef.current.focus()
}
}, [])
  return (
    <>
    <button ref={closeRef}>Close</button>
    <button ref={confirmRef}>Confirm</button>
    </>

  )
}
export default MyChild;

// Parent file
import { useRef } from 'react';
function App(ref) {
const appRef = useRef();  

return (
  <>
  <button onClick={()=> appRef.current.focusCloseRef}>Focus Close</button>
  <button onClick={()=> appRef.current.focusConfirmRef}>Focus Confirm</button>
  </>

)
}


export default App;


NOTE: You should not often use useImperativeeHandle there are very few specific cases of for its use







	