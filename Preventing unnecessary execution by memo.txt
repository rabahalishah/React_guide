------------------React.memo()
memo from memory 
This function prevent the unnecessary re-execution of the react component. This hook compares the value of props with the previous props it will allow the re-execution only when there is a change in the value of props. If the value is not change then the re-execution for this component will be skipped. In this way we can optimize our React App


**IMPORTANT: If its is so, then we dont use React.memo on all components? 
The Answer is that this React.memo comes with a cost like React must have to store it the previous value and then compare it with the new value. In this way the React have to do two things one storing the value and second one is to comparison. This will also effect the performance of React App.

But one more important thing to remember is that a regular function calling multiple time will be treated as the new value. As we know that functions are objects and two object/arrays will have the same value will not be equal. For exp:  [1,2,3]===[1,2,3] //flase and f()=== f()  //false


so this means that React.memo()  is useless for objects? cause it is unable to compare the objects despite having the fact that objects are same?
Answer is NO. To make memo useful we use an extra hook called.  useCallback()

--------useCallback() 
This hook allows us to save functions so that they could not be re-created and will have the same address in memory so that the comparison operator could work correctly.

import {useCallback} from 'React';

useCallback(function, dependencies)

this hook takes a fucntion as a first argument which we want to save and its dependencies as the second argument.

So we can use useCallback() hook on such functions about which we are sure that this function will not be changed

its dependencies are same as useEffect function. 

You can raise a question that on one side we say that 	we can use useCallback() hook on such functions about which we are sure that this function will not be changed and on the other hand we ask for dependencies. WHHHYYYY???? dependencies are needed only when you are sure that this thing will change in future. But why are we using dependencies with useCallback() argument function about which we are sure that not gonna change.

The answer is closure. The functions are closures in javaScript. Means that the variables inside this functions are coming from outside of the function may change. And function remember that value and on calling the same function again the value will be updated. Therefore we have to tell the useCallback() that dont re-create this function at any circumstances BUT re-create it only when the variable given in the depencies will change......In short we add variables in dependencies in useCallback() function to create come exceptions fro re-creating the functions.


***IMPORTANT: Since the component is re-evaluted doesn't it mean that we are re-initializing our state again and again?
Answer is NO. Since we know that react is responsible for managing our state and components. This management process will not consider the useState() while re-evaluating casue useState is coming from react and it make sure that the useState() will not re-initialize.



--------------------React Schedule and Batch execution

Whenever we make changes in our app. React do not change it instantly but it postponed the state change or may be schedule tha state. React also have priority precedence. Like it will highly prioritize the input getting from user and so on.

***IMPORTANT: 
Since we have discussed that React schedule the state updates so there is a possibility that more than one state is managed at the same time. Therefore, we use callback function inside setState function where one state is dependant on the previous state so that more than one event don not schedule at the same time.

In short React do not instantly update the state it schedule the state management.
This is the reason we do not get the latest state earlier. We get that state when the component will re-render/Re-evaluated.



Other case: if there is a case like in which a regular function we are running two setState functions line by line then React will execute both of them in Batch.



--------------------------useMemo() Hook
This hook is same as useCallback() hook but the difference is that useMemo() memoize the data whereas useCallback memoize the function. 
useCallback is more usefull than useMemo. 
In short : useCallback returns a memoized callback function, while useMemo returns a memoized value.
import {useMemo} from 'React';

useMemo(function, dependencies)


For Example: there is an expression or loop which a function is return a value that may take some time in execution if the loop is large. So if that expression is not changing then why is there any need to re-evaluate that or call that function again and again on every execution. This may lead to compromise on performance. So in order to store the value of that calculation or loop we use useMemo() Hook so that in case of not changing in its value it skip its re-evalution.